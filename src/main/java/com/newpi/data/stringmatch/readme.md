### 字符串匹配

1. 暴力算法，逐个匹配
2. 借助Hash算法实现：
    [字符串匹配算法(BF/RK/BM算法)](https://www.jianshu.com/p/40243a33d8da)
    
    RK算法的全称叫Rabin-Karp算法，是由它的两位发明者Rabin和Karp的名字来命名的。这个算法理解起来也不是很难。我个人觉得，它其实就是刚刚讲的BF算法的 升级版。

    我在讲BF算法的时候讲过，如果模式串长度为m，主串长度为n，那在主串中，就会有n-m+1个长度为m的子串，我们只需要暴力地对比这n-m+1个子串与模式串， 就可以找出主串与模式串匹配的子串。
    
    但是，每次检查主串与子串是否匹配，需要依次比对每个字符，所以BF算法的时间复杂度就比较高，是O(n*m)。
    
    我们对朴素的字符串匹配算法稍加改造，引入哈希算法时间复杂度立刻就会降低。
    
    RK算法的思路是这样的：我们通过哈希算法对主串中的n-m+1个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。
    如果某个子串的哈希值与模式串相 等那就说明对应的子串和模式串匹配了（这里先不考虑哈希冲突的问题后面我们会讲到）
    因为哈希值是个数字数字之间比较是否相等是非常快速的，所以模式串和子串比较的效率就提高了。
    
    不过，通过哈希算法计算子串的哈希值的时候，我们需要遍历子串中的每个字符。尽管模式串与子串比较的效率提高了，但是，算法整体的效率并没有提高。有
    没有方法可以提高哈希算法计算子串哈希值的效率呢？
    
    这就需要哈希算法设计的非常有技巧了。我们假设要匹配的字符串的字符集中只包含K个字符，我们可以用一个K进制数来表示一个子串，这个K进制数转化成十
    进制数作为子串的哈希值。表述起来有点抽象，我举个例子看完你应该就能懂了。
    
    比如要处理的字符串只包含a～z这26个小写字母，那我们就用二十六进制来表示一个字符串。我们把a～z这26个字符映射到0～25这26个数字，a就表示0
    示1,以此类推，z表示25。在十进制的表示法中，一个数字的值是通过下面的方式计算出来的。对应到二十六进制，一个包含a到z这26个字符的字符串，计算哈希的时候，我们只需要把进位从10改成26就可以。
    
    657 = 6 * 10 * 10 + 5 * 10 + 7 * 1
    
    cba = 'c' * 26 * 26 + 'b' * 26 + 'a' * 1
        = 2 * 26 * 26 + 1 * 26 + 0 * 1 = 1353
        
    这个哈希算法你应该看懂了吧？现在，为了方便解释，在下面的讲解中，我假设字符串中只包含a～z这26个小写字符，我们用二十六进制来表示一个字符串，对
    应的哈希值就是二十六进制数转化成十进制的结果。
3. BM算法
4. KMP算法