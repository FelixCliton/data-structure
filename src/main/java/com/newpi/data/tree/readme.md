### 树
[数据结构树(Tree)详解](http://data.biancheng.net/tree/)

二叉树
+ 本身是有序树，节点有左右孩子之分；
+ 树中包含的各个节点的度不能超过 2，即只能是 0、1 或者 2；

经过前人的总结，二叉树具有以下几个性质：
+ 二叉树中，第 i 层最多有 2^i-1 个结点。
+ 如果二叉树的深度为 K，那么此二叉树最多有 2K-1 个结点。
+ 二叉树中，终端结点数（叶子结点数）为 n0，度为 2 的结点数为 n2，则 n0=n2+1。
> 性质 3 的计算方法为：对于一个二叉树来说，除了度为 0 的叶子结点和度为 2 的结点，剩下的就是度为 1 的结点（设为 n1），那么总结点 n=n0+n1+n2。
  同时，对于每一个结点来说都是由其父结点分支表示的，假设树中分枝数为 B，那么总结点数 n=B+1。而分枝数是可以通过 n1 和 n2 表示的，即 B=n1+2*n2。所以，n 用另外一种方式表示为 n=n1+2*n2+1。
  两种方式得到的 n 值组成一个方程组，就可以得出 n0=n2+1。

满二叉树
如果二叉树中除了叶子结点，每个结点的度都为 2，则此二叉树称为满二叉树。

满二叉树除了满足普通二叉树的性质，还具有以下性质：
+ 满二叉树中第 i 层的节点数为 2n-1 个。
+ 深度为 k 的满二叉树必有 2k-1 个节点 ，叶子数为 2k-1。
+ 满二叉树中不存在度为 1 的节点，每一个分支点中都两棵深度相同的子树，且叶子节点都在最底层。
+ 具有 n 个节点的满二叉树的深度为 log2(n+1)。

完全二叉树
如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树。

对于任意一个完全二叉树来说，如果将含有的结点按照层次从左到右依次标号，对于任意一个结点 i ，完全二叉树还有以下几个结论成立：
+ 当 i>1 时，父亲结点为结点 [i/2] 。（i=1 时，表示的是根结点，无父亲结点）
+ 如果 2*i>n（总结点的个数） ，则结点 i 肯定没有左孩子（为叶子结点）；否则其左孩子是结点 2*i 。
+ 如果 2*i+1>n ，则结点 i 肯定没有右孩子；否则右孩子是结点 2*i+1 。


二叉树的存储：
顺序存储：只有完全二叉树适合采用顺序存储，否则会造成很大的空间浪费。非完全二叉树想要采用顺序存储的话，需要先把非完全二叉树转化为完全二叉树，转化方法为将缺少的节点补齐（特殊值填充）
如：堆

**题目1**：从顺序表中恢复二叉树/将二叉树采用顺序存储方式存储

链式存储：所有树都可以采用链式存储

**题目2**：创建树，遍历树（层次遍历，先序、中序、后序遍历等，递归遍历，非递归遍历）

**题目3**：根据先序和中序或者中序和后序遍历结果生成树


#### 二叉排序树 
1. 二叉排序树创建、插入、查找
2. 存在问题：二叉排序树退化成单链表，插入、查找性能下降

#### 平衡二叉树
平衡二叉树（Balanced Binary Tree）是二叉查找树的一个进化体，也是第一个引入平衡概念的二叉树。
1962年，G.M. Adelson-Velsky 和 E.M. Landis发明了这棵树，所以它又叫AVL树。
平衡二叉树要求对于每一个节点来说，它的左右子树的高度之差不能超过1，如果插入或者删除一个节点使得高度之差大于1，就要进行节点之间的旋转，将二叉树重新维持在一个平衡状态。
这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。
但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多。
#### 红黑树
红黑树是每个节点都带有颜色属性的二叉查找树，颜色或红色或黑色。  在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求:
+ 性质1. 节点是红色或黑色。
+ 性质2. 根节点是黑色。 
+ 性质3. 所有叶子都是黑色。（叶子是NIL节点） 
+ 性质4. 每个红色节点的两个子节点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色节点）
+ 性质5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

这些约束强制了红黑树的关键性质: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。
是性质4导致路径上不能有两个连续的红色节点确保了这个结果。最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因为根据性质5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。

红黑树是弱平衡二叉树，其与平衡二叉树的区别是：
+ 平衡二叉树要求绝对的平衡，左右子树高度之差不超过1
+ 红黑树只是弱平衡二叉树，只需要保证左右子树中的黑色节点数量一致即可。这只是保证了黑色节点的绝对平衡，红色节点是不考虑的，也就是说左子树和右子树只要满足2倍以内的关系就可以了

#### B树，B+树
B树是平衡多路查找树，它每个节点包含的关键字增多了，在应用时可利用磁盘块的原理把结点大小限制在磁盘大小范围内从而优化读写速度，同时树的关键字增多后层级比原理的二叉树少量，减少了数据查找次数和复杂度。

B树中每个节点包含了键值和键值对于的数据对象存放地址指针，所以成功搜索一个对象可以不用到达树的叶节点。成功搜索包括节点内搜索和沿某一路径的搜索，成功搜索时间取决于关键码所在的层次以及节点内关键码的数量。在B树中查找给定关键字的方法是：首先把根结点取来，在根结点所包含的关键字K1,…kj查找给定的关键字（可用顺序查找或二分查找法），若找到等于给定值的关键字，则查找成功；否则，一定可以确定要查的关键字在某个Ki或+1之间，于是取Pi所指的下一层索引节点块继续查找，直到找到，或指针Pi为空时查找失败。

B+树非叶节点中存放的关键码并不指示数据对象的地址指针，非也节点只是索引部分。
所有的叶节点在同一层上，包含了全部关键码和相应数据对象的存放地址指针，且叶节点按关键码从小到大顺序链接。
如果实际数据对象按加入的顺序存储而不是按关键码次数存储的话，叶节点的索引必须是稠密索引，若实际数据存储按关键码次序存放的话，
叶节点索引时稀疏索引。B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。所以 B+树有两种搜索方法：
+ 一种是按叶节点自己拉起的链表顺序搜索。
+ 一种是从根节点开始搜索，和B树类似，不过如果非叶节点的关键码等于给定值，搜索并不停止，而是继续沿右指针，
一直查到叶节点上的关键码。所以无论搜索是否成功，都将走完树的所有层。

B+ 树中，数据对象的插入和删除仅在叶节点上进行。这两种处理索引的数据结构的不同之处：
+ B树中同一键值不会出现多次，并且它有可能出现在叶结点，也有可能出现在非叶结点中。
而B+树的键一定会出现在叶结点中，并且有可能在非叶结点中也有可能重复出现，以维持B+树的平衡。
+ 因为B树键位置不定，且在整个树结构中只出现一次，虽然可以节省存储空间，但使得在插入、删除操作复杂度明显增加。
B+树相比来说是一种较好的折中。
+ B树的查询效率与键在树中的位置有关，最大时间复杂度与B+树相同(在叶结点的时候)，最小时间复杂度为1(在根结点的时候)。
而B+树的时候复杂度对某建成的树是固定的。

参考资料：
1. [二叉树、平衡二叉树、红黑树、B树、B+树与B*树](https://www.jianshu.com/p/b597aa97c9de)
2. [B树详解](https://www.jianshu.com/p/a858bb15cbf0)
3. [B-Tree与二叉查找树的对比](http://m.elecfans.com/article/662237.html)

#### LSM树
LSM树(Log-Structured-Merge-Tree)的名字往往会给初识者一个错误的印象，事实上，LSM树并不像B+树、红黑树一样是一颗严格的树状数据结构，它其实是一种存储结构，目前HBase,LevelDB,RocksDB这些NoSQL存储都是采用的LSM树。

参考资料：
[LSM树详解](https://zhuanlan.zhihu.com/p/181498475)

